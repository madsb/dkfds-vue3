import { describe, it, expect, vi, beforeEach } from 'vitest'
import { mount, VueWrapper } from '@vue/test-utils'
import { nextTick } from 'vue'
import FdsDropdown from '../fds-dropdown.vue'

// Mock the formId composable
vi.mock('dkfds-vue3-utils', () => ({
  formId: (id?: string, autogen?: boolean) => {
    return {
      formid: id || (autogen ? 'fid_autogenerated' : undefined)
    }
  }
}))

describe('FdsDropdown', () => {
  let wrapper: VueWrapper<any>
  
  beforeEach(() => {
    // Clear any previous wrapper
    wrapper?.unmount()
  })

  describe('Rendering', () => {
    it('renders select element', () => {
      wrapper = mount(FdsDropdown, {
        props: { id: 'test-dropdown' }
      })
      expect(wrapper.find('select').exists()).toBe(true)
    })

    it('renders with form-select class', () => {
      wrapper = mount(FdsDropdown, {
        props: { id: 'test-dropdown' }
      })
      expect(wrapper.find('select').classes()).toContain('form-select')
    })

    it('renders slot content (options)', () => {
      wrapper = mount(FdsDropdown, {
        props: { id: 'test-dropdown' },
        slots: {
          default: `
            <option value="">Choose...</option>
            <option value="1">Option 1</option>
            <option value="2">Option 2</option>
          `
        }
      })
      
      const options = wrapper.findAll('option')
      expect(options).toHaveLength(3)
      expect(options[0].text()).toBe('Choose...')
      expect(options[1].text()).toBe('Option 1')
      expect(options[2].text()).toBe('Option 2')
    })
  })

  describe('Props', () => {
    it('applies id to select element', () => {
      wrapper = mount(FdsDropdown, {
        props: { id: 'custom-dropdown' }
      })
      
      const select = wrapper.find('select')
      expect(select.attributes('id')).toBe('custom-dropdown')
      expect(select.attributes('name')).toBe('custom-dropdown')
    })

    it('generates id when autogen is true', () => {
      wrapper = mount(FdsDropdown)
      
      const select = wrapper.find('select')
      expect(select.attributes('id')).toBe('fid_autogenerated')
      expect(select.attributes('name')).toBe('fid_autogenerated')
    })

    it('has correct default modelValue', () => {
      wrapper = mount(FdsDropdown, {
        props: { id: 'test-dropdown' }
      })
      
      expect(wrapper.vm.modelValue).toBe('')
    })
  })

  describe('v-model', () => {
    it('emits update:modelValue on change', async () => {
      wrapper = mount(FdsDropdown, {
        props: {
          id: 'test-dropdown',
          modelValue: ''
        },
        slots: {
          default: `
            <option value="">Choose...</option>
            <option value="1">Option 1</option>
            <option value="2">Option 2</option>
          `
        }
      })
      
      const select = wrapper.find('select').element as HTMLSelectElement
      select.value = '1'
      await wrapper.find('select').trigger('change')
      
      expect(wrapper.emitted('update:modelValue')).toBeTruthy()
      // The event might be triggered on mount, check the last emission
      const emissions = wrapper.emitted('update:modelValue')
      expect(emissions[emissions.length - 1]).toEqual(['1'])
    })

    it('updates selected value when modelValue changes', async () => {
      wrapper = mount(FdsDropdown, {
        props: {
          id: 'test-dropdown',
          modelValue: '1'
        },
        slots: {
          default: `
            <option value="1">Option 1</option>
            <option value="2">Option 2</option>
          `
        }
      })
      
      // Vue should handle the selected state based on modelValue
      // We need to verify the select element reflects the correct value
      const select = wrapper.find('select').element as HTMLSelectElement
      await nextTick()
      
      // Note: In a real DOM environment, the browser would set the value
      // In JSDOM/happy-dom, we may need to verify differently
      expect(wrapper.vm.modelValue).toBe('1')
    })
  })

  describe('Events', () => {
    it('emits dirty event on blur', async () => {
      wrapper = mount(FdsDropdown, {
        props: { id: 'test-dropdown' }
      })
      
      await wrapper.find('select').trigger('blur')
      
      expect(wrapper.emitted('dirty')).toBeTruthy()
      expect(wrapper.emitted('dirty')[0]).toEqual([true])
    })

    it('adds dirty class after blur', async () => {
      wrapper = mount(FdsDropdown, {
        props: { id: 'test-dropdown' }
      })
      
      expect(wrapper.find('select').classes()).not.toContain('dirty')
      
      await wrapper.find('select').trigger('blur')
      await nextTick()
      
      expect(wrapper.find('select').classes()).toContain('dirty')
    })

    it('dispatches change event on mount', async () => {
      const dispatchEventSpy = vi.spyOn(HTMLSelectElement.prototype, 'dispatchEvent')
      
      wrapper = mount(FdsDropdown, {
        props: { id: 'test-dropdown' }
      })
      
      await nextTick()
      
      expect(dispatchEventSpy).toHaveBeenCalledWith(expect.any(Event))
      const event = dispatchEventSpy.mock.calls[0][0]
      expect(event.type).toBe('change')
      
      dispatchEventSpy.mockRestore()
    })
  })

  describe('Edge cases', () => {
    it('handles empty slots', () => {
      wrapper = mount(FdsDropdown, {
        props: { id: 'test-dropdown' }
      })
      
      expect(wrapper.find('select').element.children.length).toBe(0)
    })

    it('handles null id', () => {
      wrapper = mount(FdsDropdown, {
        props: { id: null }
      })
      
      expect(wrapper.find('select').attributes('id')).toBe('fid_autogenerated')
    })

    it('handles change event with null value', async () => {
      wrapper = mount(FdsDropdown, {
        props: {
          id: 'test-dropdown',
          modelValue: '1'
        },
        slots: {
          default: `
            <option value="">None</option>
            <option value="1">Option 1</option>
          `
        }
      })
      
      await wrapper.find('select').setValue('')
      
      expect(wrapper.emitted('update:modelValue')[0]).toEqual([''])
    })

    it('maintains dirty state across multiple interactions', async () => {
      wrapper = mount(FdsDropdown, {
        props: { id: 'test-dropdown' }
      })
      
      // First blur - should set dirty
      await wrapper.find('select').trigger('blur')
      expect(wrapper.find('select').classes()).toContain('dirty')
      
      // Change value - dirty class should remain
      await wrapper.find('select').trigger('change')
      expect(wrapper.find('select').classes()).toContain('dirty')
      
      // Another blur - should still be dirty
      await wrapper.find('select').trigger('blur')
      expect(wrapper.find('select').classes()).toContain('dirty')
    })
  })

  describe('Integration with options', () => {
    it('works with disabled options', () => {
      wrapper = mount(FdsDropdown, {
        props: { id: 'test-dropdown' },
        slots: {
          default: `
            <option value="1">Option 1</option>
            <option value="2" disabled>Option 2 (disabled)</option>
            <option value="3">Option 3</option>
          `
        }
      })
      
      const options = wrapper.findAll('option')
      expect(options[1].attributes('disabled')).toBeDefined()
    })

    it('works with option groups', () => {
      wrapper = mount(FdsDropdown, {
        props: { id: 'test-dropdown' },
        slots: {
          default: `
            <optgroup label="Group 1">
              <option value="1">Option 1</option>
              <option value="2">Option 2</option>
            </optgroup>
            <optgroup label="Group 2">
              <option value="3">Option 3</option>
              <option value="4">Option 4</option>
            </optgroup>
          `
        }
      })
      
      const optgroups = wrapper.findAll('optgroup')
      expect(optgroups).toHaveLength(2)
      expect(optgroups[0].attributes('label')).toBe('Group 1')
      expect(optgroups[1].attributes('label')).toBe('Group 2')
    })
  })

  describe('Accessibility', () => {
    it('has proper name attribute for form submission', () => {
      wrapper = mount(FdsDropdown, {
        props: { id: 'form-field' }
      })
      
      expect(wrapper.find('select').attributes('name')).toBe('form-field')
    })

    it('supports native select accessibility attributes', () => {
      wrapper = mount(FdsDropdown, {
        props: { id: 'test-dropdown' },
        attrs: {
          'aria-label': 'Choose an option',
          'aria-describedby': 'help-text',
          'required': true,
          'multiple': true
        }
      })
      
      const select = wrapper.find('select')
      expect(select.attributes('aria-label')).toBe('Choose an option')
      expect(select.attributes('aria-describedby')).toBe('help-text')
      expect(select.attributes('required')).toBeDefined()
      expect(select.attributes('multiple')).toBeDefined()
    })
  })
})