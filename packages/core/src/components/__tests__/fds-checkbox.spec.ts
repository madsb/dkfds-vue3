import { describe, it, expect, vi } from 'vitest'
import { mount, VueWrapper } from '@vue/test-utils'
import { nextTick } from 'vue'
import FdsCheckbox from '../fds-checkbox.vue'

// Mock the formId composable
vi.mock('dkfds-vue3-utils', () => ({
  formId: (id?: string, autogen?: boolean) => {
    return {
      formid: id || (autogen ? 'fid_autogenerated' : undefined)
    }
  }
}))

describe('FdsCheckbox', () => {
  let wrapper: VueWrapper<any>

  describe('Rendering', () => {
    it('renders fieldset wrapper', () => {
      wrapper = mount(FdsCheckbox)
      expect(wrapper.find('fieldset').exists()).toBe(true)
    })

    it('renders checkbox input', () => {
      wrapper = mount(FdsCheckbox)
      const input = wrapper.find('input[type="checkbox"]')
      expect(input.exists()).toBe(true)
      expect(input.classes()).toContain('form-checkbox')
    })

    it('renders label with for attribute', () => {
      wrapper = mount(FdsCheckbox, {
        props: { id: 'test-checkbox' }
      })
      
      const label = wrapper.find('label')
      expect(label.exists()).toBe(true)
      expect(label.attributes('for')).toBe('test-checkbox')
      expect(label.classes()).toContain('hand')
    })

    it('renders slot content in label', () => {
      wrapper = mount(FdsCheckbox, {
        slots: {
          default: 'Accept terms and conditions'
        }
      })
      
      expect(wrapper.find('label').text()).toBe('Accept terms and conditions')
    })

    it('renders with large size by default', () => {
      wrapper = mount(FdsCheckbox)
      expect(wrapper.find('input').classes()).toContain('checkbox-large')
    })

    it('renders with small size when specified', () => {
      wrapper = mount(FdsCheckbox, {
        props: { size: 'small' }
      })
      expect(wrapper.find('input').classes()).not.toContain('checkbox-large')
    })
  })

  describe('Props', () => {
    it('applies id to checkbox input', () => {
      wrapper = mount(FdsCheckbox, {
        props: { id: 'custom-checkbox' }
      })
      
      expect(wrapper.find('input').attributes('id')).toBe('custom-checkbox')
    })

    it('generates id when autogen is true', () => {
      wrapper = mount(FdsCheckbox)
      
      expect(wrapper.find('input').attributes('id')).toBe('fid_autogenerated')
    })

    it('reflects modelValue as checked state', async () => {
      wrapper = mount(FdsCheckbox, {
        props: {
          modelValue: true
        }
      })
      
      await nextTick()
      const input = wrapper.find('input').element as HTMLInputElement
      expect(input.checked).toBe(true)
    })

    it('has correct default props', () => {
      wrapper = mount(FdsCheckbox)
      
      expect(wrapper.vm.modelValue).toBe(false)
      expect(wrapper.vm.size).toBe('large')
    })
  })

  describe('v-model', () => {
    it('emits update:modelValue when checked', async () => {
      wrapper = mount(FdsCheckbox, {
        props: { modelValue: false }
      })
      
      const input = wrapper.find('input')
      await input.setChecked(true)
      
      expect(wrapper.emitted('update:modelValue')).toBeTruthy()
      expect(wrapper.emitted('update:modelValue')[0]).toEqual([true])
    })

    it('emits update:modelValue when unchecked', async () => {
      wrapper = mount(FdsCheckbox, {
        props: { modelValue: true }
      })
      
      const input = wrapper.find('input')
      await input.setChecked(false)
      
      expect(wrapper.emitted('update:modelValue')).toBeTruthy()
      expect(wrapper.emitted('update:modelValue')[0]).toEqual([false])
    })

    it('updates checked state when modelValue changes', async () => {
      wrapper = mount(FdsCheckbox, {
        props: { modelValue: false }
      })
      
      await wrapper.setProps({ modelValue: true })
      await nextTick()
      
      const input = wrapper.find('input').element as HTMLInputElement
      expect(input.checked).toBe(true)
    })
  })

  describe('Content slot', () => {
    it('renders content slot when provided', () => {
      wrapper = mount(FdsCheckbox, {
        slots: {
          content: '<p>Additional content</p>'
        }
      })
      
      const content = wrapper.find('.checkbox-content')
      expect(content.exists()).toBe(true)
      expect(content.find('p').text()).toBe('Additional content')
    })

    it('does not render content div when slot is empty', () => {
      wrapper = mount(FdsCheckbox)
      
      expect(wrapper.find('.checkbox-content').exists()).toBe(false)
    })

    it('has correct id for content section', () => {
      wrapper = mount(FdsCheckbox, {
        props: { id: 'test-checkbox' },
        slots: {
          content: 'Content'
        }
      })
      
      const content = wrapper.find('.checkbox-content')
      expect(content.attributes('id')).toBe('collapse-test-checkbox')
    })

    it('sets aria-hidden based on checked state', async () => {
      wrapper = mount(FdsCheckbox, {
        props: { modelValue: false },
        slots: {
          content: 'Content'
        }
      })
      
      const content = wrapper.find('.checkbox-content')
      expect(content.attributes('aria-hidden')).toBe('true')
      
      await wrapper.setProps({ modelValue: true })
      await nextTick()
      
      expect(content.attributes('aria-hidden')).toBe('false')
    })

    it('has checkbox-content-large class', () => {
      wrapper = mount(FdsCheckbox, {
        slots: {
          content: 'Content'
        }
      })
      
      const content = wrapper.find('.checkbox-content')
      expect(content.classes()).toContain('checkbox-content')
      expect(content.classes()).toContain('checkbox-content-large')
    })
  })

  describe('Events', () => {
    it('emits dirty event on blur', async () => {
      wrapper = mount(FdsCheckbox)
      
      await wrapper.find('input').trigger('blur')
      
      expect(wrapper.emitted('dirty')).toBeTruthy()
      expect(wrapper.emitted('dirty')[0]).toEqual([true])
    })
  })

  describe('Attributes', () => {
    it('passes through native input attributes', () => {
      wrapper = mount(FdsCheckbox, {
        attrs: {
          disabled: true,
          required: true,
          'aria-describedby': 'help-text',
          'data-testid': 'test-checkbox'
        }
      })
      
      const input = wrapper.find('input')
      expect(input.attributes('disabled')).toBeDefined()
      expect(input.attributes('required')).toBeDefined()
      expect(input.attributes('aria-describedby')).toBe('help-text')
      expect(input.attributes('data-testid')).toBe('test-checkbox')
    })
  })

  describe('Edge cases', () => {
    it('handles rapid toggling', async () => {
      wrapper = mount(FdsCheckbox, {
        props: { modelValue: false }
      })
      
      const input = wrapper.find('input')
      
      // Rapid toggling
      await input.setChecked(true)
      await input.setChecked(false)
      await input.setChecked(true)
      
      const emitted = wrapper.emitted('update:modelValue')
      expect(emitted).toHaveLength(3)
      expect(emitted[0]).toEqual([true])
      expect(emitted[1]).toEqual([false])
      expect(emitted[2]).toEqual([true])
    })

    it('handles null id gracefully', () => {
      wrapper = mount(FdsCheckbox, {
        props: { id: null }
      })
      
      expect(wrapper.find('input').attributes('id')).toBe('fid_autogenerated')
    })

    it('maintains internal state sync with prop', async () => {
      wrapper = mount(FdsCheckbox, {
        props: { modelValue: false }
      })
      
      // Change prop multiple times
      await wrapper.setProps({ modelValue: true })
      await wrapper.setProps({ modelValue: false })
      await wrapper.setProps({ modelValue: true })
      
      await nextTick()
      
      const input = wrapper.find('input').element as HTMLInputElement
      expect(input.checked).toBe(true)
    })
  })

  describe('Accessibility', () => {
    it('has proper label association', () => {
      wrapper = mount(FdsCheckbox, {
        props: { id: 'test-checkbox' },
        slots: {
          default: 'Checkbox label'
        }
      })
      
      const input = wrapper.find('input')
      const label = wrapper.find('label')
      
      expect(input.attributes('id')).toBe('test-checkbox')
      expect(label.attributes('for')).toBe('test-checkbox')
    })

    it('fieldset provides proper grouping', () => {
      wrapper = mount(FdsCheckbox)
      
      // Fieldset naturally groups the checkbox and label
      const fieldset = wrapper.find('fieldset')
      expect(fieldset.find('input').exists()).toBe(true)
      expect(fieldset.find('label').exists()).toBe(true)
    })

    it('supports keyboard interaction', async () => {
      wrapper = mount(FdsCheckbox)
      
      const input = wrapper.find('input')
      
      // Checkboxes should be keyboard accessible by default
      expect(input.element.tagName).toBe('INPUT')
      expect(input.attributes('type')).toBe('checkbox')
    })
  })
})